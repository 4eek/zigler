fn ___<%= func %>(env: beam.env, argc: c_int, argv: [*c] const beam.term) !beam.term {

  <%= for {param, idx} <- Enum.with_index(params) do %>
  var arg<%= idx %>: <%= param %> = undefined;<% end %>

  <%= for {param, idx} <- Enum.with_index(params) do 
    Zigler.Zig.getfor(param, idx) <> "\n"
  end %>

  var result: <%= type %> = <%= func %>(<%= if has_env, do: "env, ", else: "" %><%=
    if params == [] do
      "" 
    else
      0..Enum.count(params) - 1 |> Enum.map(&"arg#{&1}") |> Enum.join(", ") 
    end
  %>);
  <%= Zigler.Zig.makefor(type) %>
}

// all of the error handling should go here.

extern fn __<%= func %>(env: beam.env, argc: c_int, argv: [*c] const beam.term) beam.term {
  var res: beam.term = ___<%= func %>(env, argc, argv) catch | err | {
    if (err == beam.Error.FunctionClauseError) {
      return beam.throw_function_clause_error(env);
    } else if (err == error.OutOfMemory) {
      return beam.throw_enomem(env);
    } else {
      return e.enif_make_badarg(env);
    }
  };
  return res;
}

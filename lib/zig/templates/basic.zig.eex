<% needs_make? = @params |> Map.values |> Enum.any?(&Type.needs_make?(&1.type)) %>

fn <%= @name %>(env: beam.env, argc: c_int, args: [*c] const e.ErlNifTerm) callconv(.C) e.ErlNifTerm {
    beam.context = .{
        .env = env,
        .mode = .<%= context(@concurrency) %>,
        // TODO: make this be configurable
        .allocator = beam.allocator
    };

    <%= if needs_make? do %>
    var error_info = beam.make_empty_list(.{}); 
    <% end %>

    return result_block: {
        const payload_opts = .{
            <%= for {index, param} <- @params do %>
            <%= Type.render_payload_options(param.type, index, needs_make?) %>
            <% end %>
        };

        var error_index: u8 = undefined;

        const payload = beam.payload.build(nif.<%= @name %>, argc, args, &error_index, payload_opts) catch |err| {
            <%= if needs_make? do %>
                return e.enif_raise_exception(env, beam.make(.{err, error_index, error_info}, .{}).v);
            <% else %>
                _ = err;
                unreachable;
            <% end %> 
        };

        // defer beam.payload.cleanup(payload, cleanup_opts);

        const result = @call(.auto, nif.<%= @name %>, payload) <%= Nif.maybe_catch(@return.type) %>;

        <%= Return.render(@return) %>
    };
}
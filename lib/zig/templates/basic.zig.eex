fn <%= @name %>(env: beam.env, argc: c_int, args: [*c] const e.ErlNifTerm) callconv(.C) e.ErlNifTerm {
    beam.context = .{
        .env = env,
        .mode = .<%= context(@concurrency) %>,
        // TODO: make this be configurable
        .allocator = beam.allocator
    };

    return get_result: {
        const payload_opts = .{
            <%= for {index, _} <- @params do %>
            .{}
            <% end %>
        };

        var error_index: u8 = undefined;

        const payload = beam.payload.build(nif.<%= @name %>, argc, args, &error_index, payload_opts) catch |err| {
            return e.enif_raise_exception(env, beam.make(.{err, error_index, beam.make_empty_list(.{})}, .{}).v);
        };

        // defer beam.payload.cleanup(payload, cleanup_opts);

        const result = @call(.auto, nif.<%= @name %>, payload) <%= Nif.maybe_catch(@signature.return) %>;

        <%= Type.get_result(@signature.return, @return) %>
    };
}